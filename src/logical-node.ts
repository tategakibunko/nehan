import {
  Config,
  BoxEnv,
  LogicalBorder,
  ILogicalNodeEvaluator,
  ILogicalNodeEffector,
  LogicalCursorPos,
  LogicalBaseLineMetrics,
  LogicalBoxEdge,
  LogicalSize,
  PhysicalSize,
  ICharacter,
} from './public-api'

export interface ILogicalNode {
  parent?: ILogicalNode;
  dom?: HTMLElement; // set after evaluated by ILogicalNodeEvaluator.
  env: BoxEnv;
  measure: number;
  extent: number;
  progress: number; // 0.0 ~ 1.0
  text: string;
  acceptEvaluator: (visitor: ILogicalNodeEvaluator, ...args: any[]) => HTMLElement | Node;
  acceptEffector: (visitor: ILogicalNodeEffector, ...args: any[]) => void;
}

export interface ILogicalPositionalNode extends ILogicalNode {
  pos: LogicalCursorPos;
  size: LogicalSize;
}

export class LogicalTextNode implements ILogicalNode {
  constructor(
    public env: BoxEnv,
    public size: LogicalSize,
    public text: string,
    // Note that `skipBr` flag is true when
    //  1. text-node is generated by inline-overflow.
    //  2. this text-node is last node.
    // If text-node is generated by inline-overflow, text-node-generator generates text-node and LayoutResult.lineBreak.
    // This flag is used to skip <br> tag that follows just after this LayoutResult.lineBreak.
    public skipBr: boolean,
    public children: ICharacter[],
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) { }

  get measure(): number {
    return this.size.measure;
  }

  get extent(): number {
    return this.size.extent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    return visitor.visitText(this);
  }

  acceptEffector(visitor: ILogicalNodeEffector) { }
}

export class LogicalLineNode implements ILogicalPositionalNode {
  constructor(
    public env: BoxEnv,
    public pos: LogicalCursorPos,
    public size: LogicalSize,
    public autoSize: LogicalSize,
    public text: string,
    public children: ILogicalNode[],
    public baseline: LogicalBaseLineMetrics,
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) {
    this.children.forEach(child => child.parent = this);
  }

  get measure(): number {
    return this.size.measure;
  }

  get extent(): number {
    return this.size.extent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    return visitor.visitLine(this);
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    visitor.visitLine(this);
  }
}

export class LogicalRubyNode implements ILogicalNode {
  constructor(
    public env: BoxEnv,
    public size: LogicalSize,
    public text: string,
    public rb: LogicalInlineNode,
    public rt: LogicalInlineNode,
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) { }

  get measure(): number {
    return this.size.measure;
  }

  get extent(): number {
    return this.size.extent;
  }

  get lineExtent(): number {
    const lh = this.env.font.lineHeight;
    if (lh.indexOf("px") < 0) {
      return Math.floor(this.rb.env.font.size * parseFloat(lh));
    }
    return parseInt(lh);
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    return visitor.visitRuby(this);
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    visitor.visitRuby(this);
  }
}

export class LogicalInlineNode implements ILogicalNode {
  constructor(
    public env: BoxEnv,
    public size: LogicalSize,
    public text: string,
    public edge: LogicalBoxEdge,
    public children: ILogicalNode[],
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) {
    this.children.forEach(child => child.parent = this);
  }

  get measure(): number {
    return this.size.measure + this.edge.measure;
  }

  get extent(): number {
    return this.size.extent + this.edge.extent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    if (!this.env.textEmphasis.isNone()) {
      return visitor.visitInlineEmpha(this);
    }
    if (this.env.element.tagName === "a") {
      return visitor.visitInlineLink(this);
    }
    return visitor.visitInline(this);
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    visitor.visitInline(this);
  }
}

export class LogicalBlockNode implements ILogicalPositionalNode {
  constructor(
    public env: BoxEnv,
    public pos: LogicalCursorPos,
    public size: LogicalSize, // padding box size
    public autoSize: LogicalSize, // size based with cursor pos
    public text: string,
    public border: LogicalBorder,
    public children: ILogicalNode[],
    public progress: number,
    public dom: HTMLElement | undefined = undefined,
  ) {
    this.children.forEach(child => child.parent = this);
  }

  get measure(): number {
    return this.size.measure + this.env.edge.measure;
  }

  get extent(): number {
    return this.size.extent + this.border.width.extent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    switch (this.env.element.tagName) {
      case "a":
        return visitor.visitBlockLink(this);
      case Config.pageRootTagName:
        const rootBlock = visitor.visitRootBlock(this);
        rootBlock.appendChild(visitor.visitBlock(this));
        return rootBlock;
    }
    return visitor.visitBlock(this);
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    visitor.visitBlock(this);
  }
}

export class LogicalInlineBlockNode implements ILogicalPositionalNode {
  constructor(
    public env: BoxEnv,
    public pos: LogicalCursorPos,
    public size: LogicalSize, // padding box size
    public autoSize: LogicalSize, // size based with cursor pos
    public text: string,
    public edge: LogicalBoxEdge,
    public children: ILogicalNode[],
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) {
    this.children.forEach(child => child.parent = this);
  }

  get measure(): number {
    return this.size.measure + this.edge.measure;
  }

  get extent(): number {
    return this.size.extent + this.edge.extent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    return visitor.visitInlineBlock(this);
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    visitor.visitInlineBlock(this);
  }
}

export class LogicalTableCellsNode implements ILogicalNode {
  constructor(
    public env: BoxEnv,
    public size: LogicalSize,
    public pos: LogicalCursorPos,
    public text: string,
    public children: ILogicalNode[],
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) {
    this.children.forEach(child => child.parent = this);
  }

  get measure(): number {
    return this.size.measure;
  }

  get extent(): number {
    return this.size.extent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    return visitor.visitTableCells(this);
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    visitor.visitTableCells(this);
  }
}

export class LogicalBlockReNode implements ILogicalPositionalNode {
  constructor(
    public env: BoxEnv,
    public size: LogicalSize, // logical content size
    public physicalSize: PhysicalSize,
    public edge: LogicalBoxEdge,
    public pos: LogicalCursorPos,
    public text: string,
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) { }

  get measure(): number {
    return this.size.measure + this.edge.borderBoxMeasure;
  }

  get extent(): number {
    return this.size.extent + this.env.edge.borderBoxExtent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    if (this.env.element.$dom) {
      return visitor.visitBlockReFixed(this);
    }
    switch (this.env.element.tagName) {
      case "img": return visitor.visitBlockImage(this);
      case "video": return visitor.visitBlockVideo(this);
    }
    console.error("unsupported replaced element:", this);
    throw new Error("unsupported replaced element");
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    switch (this.env.element.tagName) {
      case "img": visitor.visitBlockImage(this); break;
      case "video": visitor.visitBlockVideo(this); break;
    }
  }
}

export class LogicalInlineReNode implements ILogicalNode {
  constructor(
    public env: BoxEnv,
    public size: LogicalSize, // logical content size
    public physicalSize: PhysicalSize,
    public edge: LogicalBoxEdge,
    public text: string,
    public progress = 1,
    public dom: HTMLElement | undefined = undefined,
  ) { }

  get measure(): number {
    return this.size.measure + this.edge.measure;
  }

  get extent(): number {
    return this.size.extent + this.edge.extent;
  }

  acceptEvaluator(visitor: ILogicalNodeEvaluator): HTMLElement {
    if (this.env.element.$dom) {
      return visitor.visitInlineReFixed(this);
    }
    switch (this.env.element.tagName) {
      case "img": return visitor.visitInlineImage(this);
      case "video": return visitor.visitInlineVideo(this);
    }
    console.error("unsupported replaced element:", this);
    throw new Error("unsupported replaced element");
  }

  acceptEffector(visitor: ILogicalNodeEffector) {
    switch (this.env.element.tagName) {
      case "img": visitor.visitInlineImage(this); break;
      case "video": visitor.visitInlineVideo(this); break;
    }
  }
}